reference {
  akka {
    management {
      http {
        hostname = 127.0.0.1
        hostname = ${?MANAGEMENT_HTTP_HOST}
        port = 8558
        port = ${?MANAGEMENT_HTTP_PORT}
        bind-hostname = 0.0.0.0
        bind-hostname = ${?MANAGEMENT_HTTP_BIND_HOST}
        bind-port = 8558
        bind-port = ${?MANAGEMENT_HTTP_BIND_PORT}
      }
    }
    remote {
      artery {
        transport = tcp
        canonical{
          hostname = 127.0.0.1
          hostname = ${?REMOTING_HOST}
          port = 2552
          port = ${?REMOTING_PORT}
        }
        bind {
          hostname = 127.0.0.1
          hostname = ${?REMOTING_BIND_HOST}
          port = 2552
          port = ${?REMOTING_BIND_PORT}
        }
        advanced {
          maximum-frame-size = 16 MiB
        }
      }
      log-remote-lifecycle-events = off
    }

    coordinated-shutdown {
      phases {
        service-requests-done {
          timeout=135s
        }
        before-actor-system-terminate {
            timeout=30s
        }
      }
    }
    coordinated-shutdown.exit-jvm = on

    loggers = ["akka.event.slf4j.Slf4jLogger"]
    loglevel = "DEBUG"
    logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

    http {
      host-connection-pool {
        max-open-requests = 2048
        max-retries = 0
        max-connection-backoff = 1000 ms
        max-connections = 100
      }
      server.parsing.max-content-length = 120m
      server.parsing.max-chunk-size= 120m
      client.parsing.max-chunk-size= 120m
    }
  }
  cinnamon {
    akka {
      actors {
        "/user/*" {
          report-by = class
        }
      }
    }
    prometheus {
      exporters += http-server
      http-server {
        host = 127.0.0.1
        host = ${?PROMETHEUS_HOST}
        port = 9091
        port = ${?PROMETHEUS_PORT}
      }
    }
    slf4j.mdc {
      serialization.limit = 2048 bytes
    }
  }
  cinnamon.akka.http.servers {
    "*:*" {
      paths {
        "*" {
          metrics = on
        }
      }
    }
  }
  cinnamon.akka.http.clients {
    "*:*" {
      paths {
        "*" {
          metrics = on
        }
      }
    }
  }
  eventhub-dispatcher {
    type = Dispatcher
    executor = "thread-pool-executor"
    thread-pool-executor {
     fixed-pool-size = 16
    }
    throughput = 1
  }
  http-dispatcher {
    type = Dispatcher
    executor = "thread-pool-executor"
    thread-pool-executor {
      fixed-pool-size = 32
    }
    throughput = 1
  }
  config{
    http {
      server-request-timeout = 125
      connect-timeout = 1
    }
    cert {
      sign : ${app.bundle.casogei.path}
    }
    ftp{
      connect-timeout = 1000
    }
    db {
        postgres {
          profile = "slick.jdbc.PostgresProfile$"
          db {
            dataSourceClassName = "org.postgresql.ds.PGSimpleDataSource"
            connectionPool = disabled
            #connectionPool = "HikariCP"
            registerMbeans = true
            numThreads= 40
            queueSize= 4000
            socketTimeout = 3000
            connectionTimeout = 3000
          }
        }
    }
  }
  httpactor {
    ssl-config {
#       debug {
#         all = true
#       }
      loose {
        acceptAnyCertificate = true
        allowWeakCiphers = true
        disableHostnameVerification = true
        allowWeakProtocols = true
      }
      disabledSignatureAlgorithms = ["MD2", "MD4", "MD5"]
      disabledKeyAlgorithms = ["DHE keySize < 2048", "ECDH keySize < 2048", "ECDHE keySize < 2048", "RSA keySize < 2048", "DSA keySize < 2048", "EC keySize < 224", "RSA keySize < 1024", "DSA keySize < 1024"]
      trustManager = {
        stores = [{
          path: ${app.bundle.cacerts.path}
        }]
      }
    }
  }
}
db {
  database {
    re = ${config.db.postgres}
    re.db.properties.user = ${DB_RE_USER}
    re.db.properties.password = ${DB_RE_PASSWORD}
    re.db.properties.url = ${DB_RE_URL}

    online = ${config.db.postgres}
    online.db.properties.user = ${DB_ONLINE_USER}
    online.db.properties.password = ${DB_ONLINE_PASSWORD}
    online.db.properties.url = ${DB_ONLINE_URL}

    offline = ${config.db.postgres}
    offline.db.properties.user = ${DB_OFFLINE_USER}
    offline.db.properties.password = ${DB_OFFLINE_PASSWORD}
    offline.db.numThreads = 20
    offline.db.queueSize= 2000
    offline.db.properties.url = ${DB_OFFLINE_URL}

    wfesp = ${config.db.postgres}
    wfesp.db.properties.user = ${DB_WFESP_USER}
    wfesp.db.properties.password = ${DB_WFESP_PASSWORD}
    wfesp.db.numThreads = 20
    wfesp.db.queueSize= 2000
    wfesp.db.properties.url = ${DB_WFESP_URL}
  }
}
jobs{
    paInviaRt {
        limitjobsSize=1000
    }
    mod3CancelV1{
        limitjobsSize=5000
    }
    mod3CancelV2{
        limitjobsSize=5000
    }
    pspChiediListaAndChiediRt {
        limitjobsSize=100
    }
    ftpUpload {
        limitDays=30
    }
    paInviaRtRecovery {
        limitjobsSize=1000
        waitTimeMinutesRtRecovery=60
    }
    all{
        bundleTimeoutSeconds=86400 #24 ore
        limitjobsSize=100
        limitDays=7

        database {
            config.db.numThreads = 20
            config.db.queueSize= 2000
            re.db.numThreads = 50
            re.db.queueSize= 5000
            online.db.numThreads = 50
            online.db.queueSize= 5000
            offline.db.numThreads = 20
            offline.db.queueSize= 2000
            wfesp.db.numThreads = 20
            wfesp.db.queueSize= 2000
          }
    }
}
app {
  apiConfigCache{
  	url="https://api.platform.pagopa.it/api-config-cache/p/v1/stakeholders/node/cache/schemas/v1"
    subscriptionKey=${API_CONFIG_CACHE_SUBSCRIPTION_KEY}
  	timeout=60
  }
  reBufferSize=500
  reFlushIntervalSeconds=5
  pdd-host-header-name=X-Original-Forwarded-For
  chiediElencoFlussiRendicontazioneDayLimit=30
  nodoChiediListaPendentiRPTDayLimit=120
  configScheduleMinutes=1
  limitjobsSize=100
  limitDays=7
  coordinatedShutdown=true
  waitAsyncProcesses=true
  coordinatedShutdownHttpTimeout=130
  coordinatedShutdownTerminationTimeout=20
  routing.useMetrics=true
  bundle.startup.timeout=120
  bundle.checkUTF8=false
  bundleTimeoutSeconds=600#10 minuti
  rendicontazionibollo.path = "/mnt/file-azure/firmatore/SID-Flussi-e-bollo/SID_cartelle/file_da_predisporre/"
  forwarder {
    subscriptionKey=${FORWARDER_SUBSCRIPTION_KEY}
  }
  reXmlLog=true
  reJsonLog=true
  azure-hub-event {
    azure-sdk-client {
      re-event {
        client-timeoput-ms = 5000
        event-hub-name = "nodo-dei-pagamenti-re"
        connection-string = ${AZURE_EVENT_HUB_RE_CONNECTION_STRING}
      }
      biz-event {
        client-timeoput-ms = 5000
        event-hub-name = "nodo-dei-pagamenti-biz-evt"
        connection-string = ${AZURE_EVENT_HUB_BIZ_EVT_CONNECTION_STRING}
      }
    }
  }

  wfesp {
    mybank {
      id="NDP_MB01"
    }
  }
  sendPaymentResult{
    v1 {
      uri="https://api.platform.pagopa.it/payment-manager/pm-per-nodo/v1/payments/send-payment-result"
      proxyUse="false"
      #proxyHost="10.97.20.35"
      #proxyPort=80
      #proxyUser=""
      #proxyPassword=""
      timeoutSeconds=80
    }
    v2 {
      uri="https://api.platform.pagopa.it/payment-manager/pm-per-nodo/v2/transactions/{transactionId}/user-receipts"
      proxyUse="false"
      #proxyHost="10.97.20.35"
      #proxyPort=80
      #proxyUser=""
      #proxyPassword=""
      timeoutSeconds=80
    }
  }
  gec {
    fees {
      uri="https://api.platform.pagopa.it/afm/node/calculator-service/v1/fees"
      subscriptionKey=${GEC_FEES_SUBSCRIPTION_KEY}
      proxyUse="false"
      #proxyHost="10.79.20.35"
      #proxyPort=80
      #proxyUser=""
      #proxyPassword=""
      timeoutSeconds=80
    }
  }
  micrometer {
    http-server {
      host = 127.0.0.1
      host = ${?MICROMETER_HOST}
      port = 9092
      port = ${?MICROMETER_PORT}
      hostname = "nodo4-micrometer"
      hostname = ${?MICROMETER_HOSTNAME}
    }
  }
}